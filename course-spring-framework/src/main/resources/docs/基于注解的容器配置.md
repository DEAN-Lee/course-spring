# **基于注解的容器配置**
> ### _**在配置Spring时，注释比XML更好吗**_
>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML更好?简短的回答是视情况而定。很长的答案是每种方法都有其优缺点，通常由开发人员决定哪种策略更适合他们。
>由于其定义方式，注释在其声明中提供了大量上下文，从而使配置更短、更简洁。但是，XML擅长在不改动源代码或重新编译组件的情况下连接组件。
>一些开发人员更喜欢连接到接近源代码的地方，而另一些人则认为带注释的类不再是pojo，而且配置变得分散且难以控制。
>
>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，
>而不涉及目标组件的源代码，而且，就工具而言，Eclipse的Spring工具支持所有配置样式。
>

基于注释的配置提供了XML设置的另一种选择，它依赖字节码元数据来连接组件，而不是使用尖括号声明。开发人员没有使用XML来描述bean连接，而是通过在相关类、
方法或字段声明上使用注释，将配置转移到组件类本身。如示例中所述:RequiredAnnotationBeanPostProcessor使用BeanPostProcessor与注释结合使用是扩展Spring IoC容器的常见方法。
例如，Spring 2.0引入了使用@Required注释强制执行必需属性的可能性。Spring 2.5使遵循相同的通用方法来驱动Spring的依赖项注入成为可能。
从本质上讲，@Autowired注解提供了与Autowiring协作器中描述的相同的功能，但是拥有更细粒度的控制和更广泛的适用性。
Spring 2.5还增加了对JSR-250注释的支持，比如@PostConstruct和@PreDestroy。Spring 3.0增加了对javax中包含的JSR-330 (Java依赖注入)注释的支持。
注入包，如@Inject和@Named。有关这些注释的详细信息可以在相关部分找到。

> 注释注入在XML注入之前执行。因此，XML配置覆盖了通过这两种方法连接的属性的注释。

与往常一样，您可以将它们注册为单独的bean定义，但是也可以通过在基于xml的Spring配置中包括以下标记来隐式地注册它们(请注意包含上下文名称空间)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

隐式注册的后处理器包括:AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor,
前述的 RequiredAnnotationBeanPostProcessor

> <context:annotation-config/> 只在定义注释的应用程序上下文中的bean上查找注释。这就是说,如果将<context:annotation-config/>放到
>WebApplicationContext,它只检查控制器中的@Autowired Bean，而不检查服务。有关更多信息，请参阅DispatcherServlet。
>

## @Required
@Required注释应用于bean属性setter方法，如下面的示例所示
```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
这个注释指出，必须在配置时通过bean定义中的显式属性值或自动装配来填充受影响的bean属性。如果未填充受影响的bean属性，容器将抛出异常。
它允许出现迫切的和显式的失败，避免了以后出现NullPointerException实例或类似的情况。我们仍然建议将断言放到bean类本身中(例如，放到init方法中)。
这样做会强制执行那些必需的引用和值，即使您在容器之外使用该类。

>
>从Spring Framework 5.1开始，@Required注释正式被弃用，支持使用构造函数注入来进行必需的设置(或者使用InitializingBean.afterPropertiesSet()的自定义实现以及bean属性setter方法)。
>

### @Autowired
>在本节包含的示例中，JSR 330 s @Inject注释可以用来代替Spring s @Autowired注释。更多细节请看这里。

您可以对构造函数应用@Autowired注解，如下面的例子所示
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
> 从Spring Framework 4.3开始，如果目标bean只定义了一个构造函数，就不再需要在构造函数上使用@Autowired注解。但是，如果有几个构造函数可用，
>并且没有主/默认构造函数，那么至少有一个构造函数必须用@Autowired注解，以指示容器使用哪一个。有关构造函数解析的详细信息，请参阅讨论。
>
您还可以将@Autowired注解应用到传统的setter方法，如下面的例子所示
```
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
您还可以将注释应用于具有任意名称和多个参数的方法，如下面的示例所示
```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
您还可以将@Autowired应用到字段，甚至与构造器混合使用，如下面的例子所示
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}

```
> 确保您的目标组件(例如，MovieCatalog或CustomerPreferenceDao)由您为@ autowire注释的注入点使用的类型一致地声明。否则，注入可能会由于运行时出现“没有找到类型匹配”错误而失败。
>
>对于通过类路径扫描找到的xml定义的bean或组件类，容器通常预先知道具体的类型。但是，对于@Bean工厂方法，您需要确保声明的返回类型具有足够的表达能力。
>对于实现多个接口的组件，或者对于可能由其实现类型引用的组件，考虑在您的工厂方法上声明最特定的返回类型(至少与引用您的bean的注入点所要求的那样特定)。
>

您还可以通过向需要该类型数组的字段或方法添加@Autowired注解来指示Spring从ApplicationContext中提供特定类型的所有bean，如下面的例子所示
```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```
这同样适用于类型化集合，如下面的示例所示

```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```
> 您的目标bean可以实现org.springframework.core。如果希望数组或列表中的项按特定顺序排序，则可以使用@Order或标准@Priority注释。
>否则，它们的顺序遵循容器中相应目标bean定义的注册顺序。
>
>您可以在目标类级别和@Bean方法上声明@Order注释，可能是针对单个bean定义(在使用相同bean类的多个定义的情况下)。@Order值可能会影响注入点的优先级，
>但是要注意它们不会影响单例启动顺序，单例启动顺序是由依赖关系和@DependsOn声明决定的正交关系。
>
>请注意标准javax.annotation.Priority注释在@Bean级别不可用，因为它不能在方法上声明。它的语义可以通过在每种类型的单个bean上结合@Order值和@Primary来建模。
>
即使是类型化的Map实例也可以自动实现，只要期望的键类型是String。映射值包含所有期望类型的bean，键包含相应的bean名称，如下面的示例所示
```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}

```
默认情况下，当给定注入点没有匹配的候选bean可用时，自动装配将失败。对于已声明的数组、集合或映射，至少需要一个匹配元素。

默认行为是将带注释的方法和字段视为指示所需的依赖项。您可以像下面的例子中所演示的那样改变这种行为，使框架可以通过将一个不可满足的注入点标记为非必需的方式跳过它(例如，通过将@Autowired中的required属性设置为false)
```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
如果一个非必需的方法的依赖项(或者它的一个依赖项，在有多个参数的情况下)不可用，那么它将根本不会被调用。在这种情况下，将根本不填充非必需字段，保留其默认值。

注入的构造函数和工厂方法参数是一种特殊情况，因为@Autowired中的必需属性有某种不同的含义，这是由于Spring的构造函数解析算法可能会处理多个构造函数。
默认情况下，构造函数和工厂方法参数是有效的，但在单构造函数场景中有一些特殊规则，比如如果没有匹配的bean可用，则多元素注入点(数组、集合、映射)解析为空实例。
这允许一种常见的实现模式，其中所有依赖可以在一个唯一的多参数构造函数中声明，例如，声明为单个公共构造函数，而不需要@Autowired注解。

> 只有一个给定bean类的构造函数可以声明@Autowired，并将required属性设置为true，以指示当作为Spring bean使用时要自动装配的构造函数。
> 因此，如果required属性的默认值为true，那么只有一个构造函数可以使用@Autowired注解。只有一个构造函数可以用@Autowired注解。
> 如果有多个构造函数声明注释，那么它们都必须声明required=false，才能被认为是自动装配的候选者(类似于XML中的autowire=constructor)。
> 通过在Spring容器中匹配bean可以满足的依赖关系最多的构造函数将被选择。如果没有一个候选函数可以满足，那么将使用主/默认构造函数(如果存在)。
> 类似地，如果一个类声明了多个构造函数，但是没有一个是用@Autowired注解的，那么一个主/默认构造函数(如果有的话)将会被使用。如果一个类只声明了一个构造函数，
> 那么它将始终被使用，即使没有注释。请注意，带注释的构造函数不必是公共的。
>
>建议在setter方法上的已弃用的@Required注释上使用@Autowired属性。将required属性设置为false表示该属性对于自动装配目的是不需要的，
>并且如果该属性不能自动装配，则忽略它。另一方面，@Required更强，因为它强制用容器支持的任何方法设置属性，如果没有定义值，则会引发相应的异常。
>

或者，您可以通过Java 8 s Java .util表示特定依赖项的非必需性质。可选，如下面的示例所示
```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```
在Spring Framework 5.0中，还可以使用@Nullable注释(任何包中的任何类型，例如javax.annotation)。或者只是利用Kotlin内置的空安全支持
```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```