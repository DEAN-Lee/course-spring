# 应用程序上下文和资源路径
本节介绍如何创建带有资源的应用程序上下文，包括使用XML的快捷方式、如何使用通配符以及其他细节。

## 构建应用程序上下文
应用程序上下文构造函数(针对特定的应用程序上下文类型)通常接受一个字符串或字符串数组作为资源的位置路径，例如组成上下文定义的XML文件。

当这样的位置路径没有前缀时，从该路径构建的用于加载bean定义的特定资源类型依赖于特定的应用程序上下文，并且适合于特定的应用程序上下文。
例如，考虑下面的示例，它创建了一个ClassPathXmlApplicationContext  
```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");
```
bean定义是从类路径加载的，因为使用了ClassPathResource。但是，考虑下面的示例，它创建了一个FileSystemXmlApplicationContext
```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");
```
现在，从文件系统位置(在本例中，相对于当前工作目录)加载bean定义。

注意，在位置路径上使用特殊的类路径前缀或标准URL前缀将覆盖为加载定义而创建的默认资源类型。考虑以下示例
```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");
```
使用FileSystemXmlApplicationContext从类路径加载bean定义。但是，它仍然是一个FileSystemXmlApplicationContext。
如果它随后被用作ResourceLoader，那么任何没有前缀的路径仍然被视为文件系统路径。

### 构造ClassPathXmlApplicationContext实例的快捷方式
ClassPathXmlApplicationContext公开了许多构造函数来启用方便的实例化。基本思想是，您可以仅提供一个字符串数组，其中只包含XML文件本身的文件名(不包含前导路径信息)，
还可以提供一个类。然后ClassPathXmlApplicationContext从提供的类派生路径信息。
考虑以下目录布局
```text
com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
```
下面的示例展示了如何实例化由名为services.xml和dao .xml(位于类路径上)的文件中定义的bean组成的ClassPathXmlApplicationContext实例
```java
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);
```
有关各种构造函数的详细信息，请参阅ClassPathXmlApplicationContext javadoc。

### 应用程序上下文构造函数资源路径中的通配符
应用程序上下文构造函数值中的资源路径可以是简单路径(如前面所示)，每个路径都有到目标资源的一对一映射，或者，也可以包含特殊的“classpath*:”
前缀或内部ant样式的正则表达式(通过使用Spring的PathMatcher实用程序进行匹配)。后者都是有效的通配符。

此机制的一种用途是在需要进行组件样式的应用程序组装时使用。所有组件都可以将上下文定义片段“发布”到一个众所周知的位置路径，并且，
当最终的应用程序上下文使用以classpath*:为前缀的相同路径创建时，所有组件片段都会被自动提取。

注意，这种通配符是特定于在应用程序上下文构造器中使用资源路径的(或者当您直接使用PathMatcher实用程序类层次结构时)，并且在构造时解析。
它与资源类型本身无关。不能使用classpath*:前缀来构造实际的资源，因为资源一次只指向一个资源。

#### ant是基于模式
路径位置可以包含ant样式的模式，如下面的示例所示
```text
/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml
```    
当路径位置包含ant样式的模式时，解析器将遵循一个更复杂的过程来尝试解析通配符。它为直到最后一个非通配符段的路径生成一个资源，并从中获取一个URL。
如果此URL不是jar: URL或特定于容器的变体(如WebLogic中的zip:、WebSphere中的wsjar等等)，则为java.io。文件从中获取，并通过遍历文件系统来解析通配符。
对于jar URL，解析器要么从中获取一个java.net.JarURLConnection，要么手动解析jar URL，然后遍历jar文件的内容以解析通配符。

#### 影响可移植性
如果指定的路径已经是文件URL(可能是隐式的，因为基本ResourceLoader是文件系统URL，也可能是显式的)，那么可以保证通配符以完全可移植的方式工作。

如果指定的路径是类路径位置，则解析器必须通过调用Classloader.getResource()来获取最后一个非通配符路径段URL。由于这只是路径的一个节点(而不是最后的文件)，
因此在这种情况下，它实际上没有确切定义(在类加载器javadoc中)返回何种类型的URL。实际上，它总是一个java.io。
表示目录(其中类路径资源解析为文件系统位置)或某种类型的jar URL(其中类路径资源解析为jar位置)的文件。不过，这个操作还有一个可移植性问题。    

如果获得了最后一个非通配符段的jar URL，那么解析器必须能够从中获得一个java.net.JarURLConnection，或者手动解析jar URL，
以便能够遍历jar的内容并解析通配符。这在大多数环境中可以工作，但在其他环境中会失败，我们强烈建议在依赖于jar资源的通配符解析之前，在您的特定环境中彻底测试它。

#### 前缀：classpath*:
在构造基于xml的应用程序上下文时，位置字符串可能使用特殊的classpath*:前缀，如下面的示例所示
```java
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
```


