# 类路径扫描和托管组件
本章中的大多数示例使用XML指定在Spring容器中生成每个BeanDefinition的配置元数据。上一节(基于注释的容器配置)演示了如何通过源代码级注释提供
大量配置元数据。然而，即使在这些示例中，基本bean定义也显式地定义在XML文件中，而注释仅驱动依赖项注入。本节描述通过扫描类路径隐式检测候选组件的选项。
候选组件是与筛选标准匹配的类，并有相应的bean定义注册到容器中。这样就不需要使用XML来执行bean注册。相反，您可以使用注释(例如@Component)、
AspectJ类型表达式或您自己的自定义筛选标准来选择哪些类已经向容器注册了bean定义。
> 从Spring 3.0开始，Spring JavaConfig项目提供的许多特性都是核心Spring框架的一部分。这允许您使用Java而不是传统的XML文件定义bean。
>查看@Configuration、@Bean、@Import和@DependsOn注释，了解如何使用这些新特性。

## @Component和进一步构造型注解
@Repository注释是满足存储库角色或构造型的任何类的标记(也称为数据访问对象或DAO)。该标记的使用包括异常的自动翻译，如异常翻译中所述。
Spring提供了进一步的构造型注解:@Component， @Service和@Controller。@Component是任何spring管理组件的通用原型。
@Repository、@Service和@Controller是针对更具体用例(分别在持久性、服务和表示层中)的@Component的专门化。
因此，您可以使用@Component来注释组件类，但是，通过使用@Repository、@Service或@Controller来注释它们，您的类更适合通过工具进行处理或切面关联。
例如，这些构造型注释是切入点的理想目标。因此，如果您要在您的服务层使用@Component或@Service之间进行选择，那么@Service显然是更好的选择。
类似地，如前所述，@Repository已经被支持作为持久化层中自动异常转换的标记。

## 使用元注释和组合注释
Spring提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。
例如，前面提到的@Service注释是用@Component进行元注释的，如下面的示例所示
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component 
public @interface Service {

    // ...
}

```
该组件导致以与@Component相同的方式处理@Service。

您还可以组合元注释来创建复合注释.例如，Spring MVC的@RestController注释由@Controller和@ResponseBody组成。

此外，组合注释可以选择性地从元注释中重新声明属性，从而允许定制。当您只想公开元注释属性的一个子集时，这可能特别有用。
例如，Spring s @SessionScope注释将作用域名称硬编码为session，但仍然允许定制proxyMode。下面的清单显示了SessionScope注释的定义.
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
```
然后可以使用@SessionScope，而不用像下面这样声明proxyMode
```java
@Service
@SessionScope
public class SessionScopedService {
    // ...
}
```
有关更多细节，请参见Spring注释编程模型wiki页面。

## 自动检测类并注册Bean定义
Spring可以自动检测原型类，并向ApplicationContext注册相应的BeanDefinition实例。例如，以下两个类适合进行这种自动检测
```java
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```
```java
@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}
```

要自动检测这些类并注册相应的bean，您需要将@ComponentScan添加到您的@Configuration类中，其中basePackages属性是这两个类的公共父包。
(或者，您可以指定一个逗号、分号或空格分隔的列表，其中包含每个类的父包。)
```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```
>为简便起见，前面的示例可以使用注释的value属性(即@ComponentScan("org.example"))。

下面的替代方法使用XML
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
```

> 使用<context:component-scan>隐式地启用了<context:annotation-config>的功能。
> 在使用<context: componentent -scan>时，通常不需要包含<context:annotation-config>元素。