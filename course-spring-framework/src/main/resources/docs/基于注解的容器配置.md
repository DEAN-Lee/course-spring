# **基于注解的容器配置**
> ### _**在配置Spring时，注释比XML更好吗**_
>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML更好?简短的回答是视情况而定。很长的答案是每种方法都有其优缺点，通常由开发人员决定哪种策略更适合他们。
>由于其定义方式，注释在其声明中提供了大量上下文，从而使配置更短、更简洁。但是，XML擅长在不改动源代码或重新编译组件的情况下连接组件。
>一些开发人员更喜欢连接到接近源代码的地方，而另一些人则认为带注释的类不再是pojo，而且配置变得分散且难以控制。
>
>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，
>而不涉及目标组件的源代码，而且，就工具而言，Eclipse的Spring工具支持所有配置样式。
>

基于注释的配置提供了XML设置的另一种选择，它依赖字节码元数据来连接组件，而不是使用尖括号声明。开发人员没有使用XML来描述bean连接，而是通过在相关类、
方法或字段声明上使用注释，将配置转移到组件类本身。如示例中所述:RequiredAnnotationBeanPostProcessor使用BeanPostProcessor与注释结合使用是扩展Spring IoC容器的常见方法。
例如，Spring 2.0引入了使用@Required注释强制执行必需属性的可能性。Spring 2.5使遵循相同的通用方法来驱动Spring的依赖项注入成为可能。
从本质上讲，@Autowired注解提供了与Autowiring协作器中描述的相同的功能，但是拥有更细粒度的控制和更广泛的适用性。
Spring 2.5还增加了对JSR-250注释的支持，比如@PostConstruct和@PreDestroy。Spring 3.0增加了对javax中包含的JSR-330 (Java依赖注入)注释的支持。
注入包，如@Inject和@Named。有关这些注释的详细信息可以在相关部分找到。

> 注释注入在XML注入之前执行。因此，XML配置覆盖了通过这两种方法连接的属性的注释。

与往常一样，您可以将它们注册为单独的bean定义，但是也可以通过在基于xml的Spring配置中包括以下标记来隐式地注册它们(请注意包含上下文名称空间)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

隐式注册的后处理器包括:AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor,
前述的 RequiredAnnotationBeanPostProcessor

> <context:annotation-config/> 只在定义注释的应用程序上下文中的bean上查找注释。这就是说,如果将<context:annotation-config/>放到
>WebApplicationContext,它只检查控制器中的@Autowired Bean，而不检查服务。有关更多信息，请参阅DispatcherServlet。
>

## @Required
@Required注释应用于bean属性setter方法，如下面的示例所示
```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
这个注释指出，必须在配置时通过bean定义中的显式属性值或自动装配来填充受影响的bean属性。如果未填充受影响的bean属性，容器将抛出异常。
它允许出现迫切的和显式的失败，避免了以后出现NullPointerException实例或类似的情况。我们仍然建议将断言放到bean类本身中(例如，放到init方法中)。
这样做会强制执行那些必需的引用和值，即使您在容器之外使用该类。

>
>从Spring Framework 5.1开始，@Required注释正式被弃用，支持使用构造函数注入来进行必需的设置(或者使用InitializingBean.afterPropertiesSet()的自定义实现以及bean属性setter方法)。
>

### @Autowired
>在本节包含的示例中，JSR 330 s @Inject注释可以用来代替Spring s @Autowired注释。更多细节请看这里。

您可以对构造函数应用@Autowired注解，如下面的例子所示
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
> 从Spring Framework 4.3开始，如果目标bean只定义了一个构造函数，就不再需要在构造函数上使用@Autowired注解。但是，如果有几个构造函数可用，
>并且没有主/默认构造函数，那么至少有一个构造函数必须用@Autowired注解，以指示容器使用哪一个。有关构造函数解析的详细信息，请参阅讨论。
>
您还可以将@Autowired注解应用到传统的setter方法，如下面的例子所示
```
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
您还可以将注释应用于具有任意名称和多个参数的方法，如下面的示例所示
```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
您还可以将@Autowired应用到字段，甚至与构造器混合使用，如下面的例子所示
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}

```
> 确保您的目标组件(例如，MovieCatalog或CustomerPreferenceDao)由您为@ autowire注释的注入点使用的类型一致地声明。否则，注入可能会由于运行时出现“没有找到类型匹配”错误而失败。
>
>对于通过类路径扫描找到的xml定义的bean或组件类，容器通常预先知道具体的类型。但是，对于@Bean工厂方法，您需要确保声明的返回类型具有足够的表达能力。
>对于实现多个接口的组件，或者对于可能由其实现类型引用的组件，考虑在您的工厂方法上声明最特定的返回类型(至少与引用您的bean的注入点所要求的那样特定)。
>

您还可以通过向需要该类型数组的字段或方法添加@Autowired注解来指示Spring从ApplicationContext中提供特定类型的所有bean，如下面的例子所示
```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```
这同样适用于类型化集合，如下面的示例所示

```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```
> 您的目标bean可以实现org.springframework.core。如果希望数组或列表中的项按特定顺序排序，则可以使用@Order或标准@Priority注释。
>否则，它们的顺序遵循容器中相应目标bean定义的注册顺序。
>
>您可以在目标类级别和@Bean方法上声明@Order注释，可能是针对单个bean定义(在使用相同bean类的多个定义的情况下)。@Order值可能会影响注入点的优先级，
>但是要注意它们不会影响单例启动顺序，单例启动顺序是由依赖关系和@DependsOn声明决定的正交关系。
>
>请注意标准javax.annotation.Priority注释在@Bean级别不可用，因为它不能在方法上声明。它的语义可以通过在每种类型的单个bean上结合@Order值和@Primary来建模。
>
即使是类型化的Map实例也可以自动实现，只要期望的键类型是String。映射值包含所有期望类型的bean，键包含相应的bean名称，如下面的示例所示
```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}

```
默认情况下，当给定注入点没有匹配的候选bean可用时，自动装配将失败。对于已声明的数组、集合或映射，至少需要一个匹配元素。

默认行为是将带注释的方法和字段视为指示所需的依赖项。您可以像下面的例子中所演示的那样改变这种行为，使框架可以通过将一个不可满足的注入点标记为非必需的方式跳过它(例如，通过将@Autowired中的required属性设置为false)
```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```
如果一个非必需的方法的依赖项(或者它的一个依赖项，在有多个参数的情况下)不可用，那么它将根本不会被调用。在这种情况下，将根本不填充非必需字段，保留其默认值。

注入的构造函数和工厂方法参数是一种特殊情况，因为@Autowired中的必需属性有某种不同的含义，这是由于Spring的构造函数解析算法可能会处理多个构造函数。
默认情况下，构造函数和工厂方法参数是有效的，但在单构造函数场景中有一些特殊规则，比如如果没有匹配的bean可用，则多元素注入点(数组、集合、映射)解析为空实例。
这允许一种常见的实现模式，其中所有依赖可以在一个唯一的多参数构造函数中声明，例如，声明为单个公共构造函数，而不需要@Autowired注解。

> 只有一个给定bean类的构造函数可以声明@Autowired，并将required属性设置为true，以指示当作为Spring bean使用时要自动装配的构造函数。
> 因此，如果required属性的默认值为true，那么只有一个构造函数可以使用@Autowired注解。只有一个构造函数可以用@Autowired注解。
> 如果有多个构造函数声明注释，那么它们都必须声明required=false，才能被认为是自动装配的候选者(类似于XML中的autowire=constructor)。
> 通过在Spring容器中匹配bean可以满足的依赖关系最多的构造函数将被选择。如果没有一个候选函数可以满足，那么将使用主/默认构造函数(如果存在)。
> 类似地，如果一个类声明了多个构造函数，但是没有一个是用@Autowired注解的，那么一个主/默认构造函数(如果有的话)将会被使用。如果一个类只声明了一个构造函数，
> 那么它将始终被使用，即使没有注释。请注意，带注释的构造函数不必是公共的。
>
>建议在setter方法上的已弃用的@Required注释上使用@Autowired属性。将required属性设置为false表示该属性对于自动装配目的是不需要的，
>并且如果该属性不能自动装配，则忽略它。另一方面，@Required更强，因为它强制用容器支持的任何方法设置属性，如果没有定义值，则会引发相应的异常。
>

或者，您可以通过Java 8 java.util.Optional表示特定依赖项的非必需性质。可选，如下面的示例所示
```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```
在Spring Framework 5.0中，还可以使用@Nullable注释(任何包中的任何类型，例如javax.annotation)。或者只是利用Kotlin内置的空安全支持
```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

你也可以使用@Autowired的接口是众所周知的可解析依赖:BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher，和MessageSource。
这些接口及其扩展接口，如ConfigurableApplicationContext或ResourcePatternResolver，会自动解析，不需要特殊设置。
下面的示例自动生成一个ApplicationContext对象
```java
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}
```
>@Autowired， @Inject， @Value，和@Resource注解是由Spring BeanPostProcessor实现处理的。这意味着您不能在自己的BeanPostProcessor
>或BeanFactoryPostProcessor类型(如果有的话)中应用这些注释。这些类型必须通过使用XML或Spring @Bean方法显式地“连接起来”。
>
### 使用@Primary微调基于注释的自动装配
容器内有多个自动装配实例对象时，@Primary选择一个为主类型对象。当需要对选择过程进行更多控制时，可以使用Spring s @Qualifier注释。
您可以将限定符值与特定的参数相关联，从而缩小类型匹配的范围，以便为每个参数选择特定的bean。
在最简单的情况下，这可以是一个普通的描述性值，如下面的示例所示
```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}
```

您还可以在单独的构造函数参数或方法参数上指定@Qualifier注释，如下面的示例所示
```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}

```
下面的示例显示了相应的bean定义。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="main"/> 

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="action"/> 

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```
具有主限定符值的bean与使用相同值限定的构造函数参数连接。
具有动作限定符值的bean与使用相同值限定的构造函数参数连接。

对于回退匹配，bean名称被认为是默认的限定符值。因此，您可以使用id为main而不是嵌套的qualifier元素来定义bean，从而得到相同的匹配结果。
然而，尽管您可以使用这种约定来按名称引用特定的bean，但@Autowired基本上是关于类型驱动的注入，带有可选的语义限定符。
这意味着，即使使用了bean名称回退，限定符值也总是在类型匹配集中具有收缩语义。它们在语义上没有表达对唯一bean id的引用。
好的限定符值是main、EMEA或persistent，表示独立于bean id的特定组件的特征，在匿名bean定义(如前面示例中的bean定义)的情况下，bean id可以自动生成。

限定符也适用于类型化集合，如前面所讨论的，例如设置<MovieCatalog>。在这种情况下，根据声明的限定符，所有匹配的bean都作为一个集合注入。
这意味着限定符不必是惟一的。相反，它们构成了过滤标准。例如，您可以定义具有相同限定符值操作的多个MovieCatalog bean，
所有这些bean都被注入到带有@Qualifier(“action”)注释的<MovieCatalog>集合中。

>让限定符值在类型匹配候选中针对目标bean名称进行选择，不需要在注入点使用@Qualifier注释。
>如果没有其他解析指示器(例如限定符或主标记)，对于非唯一依赖情况，Spring将注入点名称(即字段名称或参数名称)与目标bean名称匹配，并选择同名的候选对象(如果有的话)。

也就是说，如果您打算通过名称表示注释驱动的注入，请不要主要使用@Autowired，即使它能够通过bean名称在类型匹配的候选者中进行选择。
相反，使用JSR-250 @Resource注释，它在语义上定义为通过惟一名称标识特定的目标组件，声明的类型与匹配过程无关。
@Autowired有相当不同的语义:在按类型选择候选bean之后，指定的字符串限定符值只在那些类型选择的候选者中被考虑(例如，将一个帐户限定符与用相同限定符标签标记的bean相匹配)。

对于本身定义为集合、映射或数组类型的bean， @Resource是一个很好的解决方案，它通过惟一的名称引用特定的集合或数组bean。
也就是说，只要元素类型信息保存在@Bean返回类型签名或集合继承层次结构中，就可以通过Spring s @Autowired类型匹配算法匹配Map和数组类型。
在这种情况下，您可以使用限定符值在相同类型的集合中进行选择，如前一段所述。

在4.3中，@Autowired也考虑注入的自我引用(也就是说，对当前被注入的bean的引用)。注意，self注入是一种退路.对其他组件的常规依赖始终具有优先级。
从这个意义上说，自我参照不参与候选人的定期选择，因此，尤其从来没有初选。相反，它们总是优先级最低的.
在实践中，您应该仅将self引用用作最后的手段(例如，通过bean s事务代理调用同一实例上的其他方法)。在这种情况下，
考虑将受影响的方法分解为单独的委托bean。或者，您可以使用@Resource，它可以通过当前bean的惟一名称获得回它的代理