# **基于注解的容器配置**
> ### _**在配置Spring时，注释比XML更好吗**_
>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML更好?简短的回答是视情况而定。很长的答案是每种方法都有其优缺点，通常由开发人员决定哪种策略更适合他们。
>由于其定义方式，注释在其声明中提供了大量上下文，从而使配置更短、更简洁。但是，XML擅长在不改动源代码或重新编译组件的情况下连接组件。
>一些开发人员更喜欢连接到接近源代码的地方，而另一些人则认为带注释的类不再是pojo，而且配置变得分散且难以控制。
>
>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，
>而不涉及目标组件的源代码，而且，就工具而言，Eclipse的Spring工具支持所有配置样式。
>

基于注释的配置提供了XML设置的另一种选择，它依赖字节码元数据来连接组件，而不是使用尖括号声明。开发人员没有使用XML来描述bean连接，而是通过在相关类、
方法或字段声明上使用注释，将配置转移到组件类本身。如示例中所述:RequiredAnnotationBeanPostProcessor使用BeanPostProcessor与注释结合使用是扩展Spring IoC容器的常见方法。
例如，Spring 2.0引入了使用@Required注释强制执行必需属性的可能性。Spring 2.5使遵循相同的通用方法来驱动Spring的依赖项注入成为可能。
从本质上讲，@Autowired注解提供了与Autowiring协作器中描述的相同的功能，但是拥有更细粒度的控制和更广泛的适用性。
Spring 2.5还增加了对JSR-250注释的支持，比如@PostConstruct和@PreDestroy。Spring 3.0增加了对javax中包含的JSR-330 (Java依赖注入)注释的支持。
注入包，如@Inject和@Named。有关这些注释的详细信息可以在相关部分找到。

> 注释注入在XML注入之前执行。因此，XML配置覆盖了通过这两种方法连接的属性的注释。

与往常一样，您可以将它们注册为单独的bean定义，但是也可以通过在基于xml的Spring配置中包括以下标记来隐式地注册它们(请注意包含上下文名称空间)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

隐式注册的后处理器包括:AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor,
前述的 RequiredAnnotationBeanPostProcessor

> <context:annotation-config/> 只在定义注释的应用程序上下文中的bean上查找注释。这就是说,如果将<context:annotation-config/>放到
>WebApplicationContext,它只检查控制器中的@Autowired Bean，而不检查服务。有关更多信息，请参阅DispatcherServlet。
>

## @Required
@Required注释应用于bean属性setter方法，如下面的示例所示
```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```