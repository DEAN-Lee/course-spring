# 抽象环境
环境接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模： profiles 和 properties.

概要文件是一个命名的bean定义逻辑组，只有在给定的概要文件处于活动状态时才向容器注册。bean可以被分配给一个配置文件，无论这个配置文件是用XML定义的还是用注释定义的。
与概要文件相关的Environment对象的作用是确定哪些概要文件(如果有的话)当前处于活动状态，以及默认情况下哪些概要文件(如果有的话)应该处于活动状态。

属性在几乎所有的应用程序中都扮演着重要的角色，并且可以来自各种来源:属性文件、JVM系统属性、系统环境变量、JNDI、servlet上下文参数、特别的属性对象、映射对象等等。
与属性相关的环境对象的作用是为用户提供一个方便的服务接口，用于配置属性源和从属性源解析属性。

## Bean定义概要文件
Bean定义概要文件在核心容器中提供了一种机制，允许在不同环境中注册不同的Bean。对于不同的用户，环境这个词可能有不同的含义，这个特性可以帮助处理许多用例，包括

* 在开发中使用内存中的数据源，而在QA或生产中从JNDI查找相同的数据源。
* 仅在将应用程序部署到性能环境中时才注册监视基础设施。
* 对客户A和客户B部署的自定义bean实现进行注册。

考虑需要数据源的实际应用程序中的第一个用例。在测试环境中，配置可能类似于以下内容
```java
@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}
```
现在考虑如何将该应用程序部署到QA或生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录中。我们的数据源bean现在看起来如下所示
```java
@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}
```

问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring用户已经设计了许多方法来实现这一点，通常依赖于系统环境变量和XML 语句的组合，
这些语句包含${import}令牌，这些令牌根据环境变量的值解析为正确的配置文件路径。Bean定义概要文件是为这个问题提供解决方案的核心容器特性.

如果我们泛化前面环境特定bean定义示例中所示的用例，我们最终需要在某些上下文中注册某些bean定义，而不是在其他上下文中。您可以说，您希望在情形a中注册某个bean定义的概要文件，
在情形b中注册一个不同的概要文件。我们首先更新配置以反映这一需求。

## 使用@Profile
当一个或多个指定的概要文件处于活动状态时，@Profile注释可以指示组件是否有资格注册。使用前面的示例，我们可以重写数据源配置，如下所示
```java
@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}

@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
```
> @ bean方法,如前所述,您通常选择使用程序化的JNDI查找,通过使用Spring的JndiTemplate / JndiLocatorDelegate助手
>或直接使用JNDI InitialContext JndiObjectFactoryBean变体,但不是早些时候显示这将迫使你声明返回类型作为FactoryBean类型。



